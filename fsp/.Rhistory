knitr::opts_chunk$set(eval = T, echo = F, message = F, cache = FALSE)
# Load required packages
library(neonOSqc)
library(neonUtilities)
library(neonOS)
library(DT)
library(glue)
library(dplyr)
library(tidyr)
library(ggplot2)
library(restR2)
# Set DT options for consistent table formatting
dtOptions <- list(
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel'),
pageLength = 25,
scrollX = TRUE
)
# Set date variables for FSP QC report
startDate_checked <- "2022-01"  # Start date for data download
endDate_checked <- "2022-12"    # End date for data download
print(paste0('First year-month of input data = ', startDate_checked, '. Last year-month of input data = ', endDate_checked, "."))
# Set script type
scriptType <- "annual"
annual = TRUE # Set to TRUE for annual data pull
# What is the name and timestamp for the report? Need when outputs go to GCS
reportTimestamp <- format(Sys.time(), "%Y%m%d%H%M%S")
reportName <- paste0("fsp_annual_", format(Sys.Date(), "%Y"), "_", reportTimestamp)
# Load portal data - CFC (for cross-reference completeness checks)
canopyFoliage <- try(neonUtilities::loadByProduct(
dpID='DP1.10026.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
#release = "LATEST",
token = Sys.getenv('NEON_PAT')), # Using NEON_PAT token
silent = T)
# Load portal data - FSP (expanded package to include dataQF field)
spectra <- try(neonUtilities::loadByProduct(
dpID='DP1.30012.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
package = "expanded",  # Use expanded package to include dataQF field
#release = "LATEST",
token = Sys.getenv('NEON_PAT')), # Using NEON_PAT token
silent = T)
View(spectra)
# Turn all tables in the list to dataframe (DF) in the global environment, where name of table = name of DF.
# If the data list has no data, then stop and don't run the script
if(is.null(attr(spectra, "class"))){
invisible(list2env(spectra, envir=.GlobalEnv))
#print("FSP data loaded successfully")
}else{
print("There are no FSP data in this date range to check, no script outputs generated.")
knitr::knit_exit()
}
if(is.null(attr(canopyFoliage, "class"))){
invisible(list2env(canopyFoliage, envir=.GlobalEnv))
#print("CFC data loaded successfully")
}else{
print("There are no CFC data in this date range to check, cross-reference completeness checks will be skipped.")
}
View(validation_30012)
View(fsp_spectralData)
knitr::opts_chunk$set(eval = T, echo = F, message = F)
version$version.string
print(paste("neonOSqc version:", packageVersion("neonOSqc")))
# Set date variables from render file
startDate_checked <- params$startMonth
endDate_checked <- params$endMonth
print(paste0('First year-month of input data = ', startDate_checked, '. Last year-month of input data = ', endDate_checked, "."))
# Load CRAN packages
library(neonUtilities) # functions to download portal data
library(neonOS) # function for dup checking, recommend using the CRAN version
library(devtools)# functions for interacting with packages (if needed)
library(tidyverse) # these functions are used in the template to work with data frames
# Install packages from GitHub if not done or not updated in a while - else comment out
# Note that 'install_local' can also work, as long as repo is synced should be same outcome
# install_github('NEONScience/neonOSqc')
# install_github("NEONScience/restR2")
# Load internal NEON packages
library(neonOSqc) # OS QC functions
library(restR2) # if using restR2 calls directly
# Set options for DT:datatables
dtOptions = list(
paging = FALSE,
scrollX = TRUE,
scrollY = "42vh",
scrollCollapse = TRUE,
buttons = 'csv',
dom='B<"top"i>t',
columnDefs = list(
list(className = "dt-left", targets = "_all")
)
)
# Set script type from render file
scriptType <- params$monthlyAnnual
annual = ifelse(scriptType == "annual", T, F) # optional, if the 'annual' parameter is used to set chunks to run or not based on one month vs annual data pull
# What is the name and timestamp for the report? Need when outputs go to GCS
reportTimestamp <- params$reportTimestamp
reportName <- params$reportName
# Load portal data - FSP (expanded package to get all fields including downloadFileUrl)
spectra <- try(neonUtilities::loadByProduct(
dpID='DP1.30012.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
package = "expanded",  # Important for getting downloadFileUrl
#release = "LATEST",
token = Sys.getenv('NEON_PAT'), # remove this line if you don't have a token, though everyone is encouraged to get one
silent = T))
# Load portal data - CFC (for cross-reference checks)
canopyFoliage <- try(neonUtilities::loadByProduct(
dpID='DP1.10026.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
#release = "LATEST",
token = Sys.getenv('NEON_PAT'),
silent = T))
# if the data list has no data, then stop and don't run the script
if(identical(names(spectra), "NONE")){
print("There are no FSP data in this date range to check, no script outputs generated.")
knitr::knit_exit()
}else{
# Turn all tables in the list to dataframe (DF) in the global environment, where name of table = name of DF.
invisible(list2env(spectra, envir=.GlobalEnv))
}
library(neonUtilities) # functions to download portal data
library(neonOS) # function for dup checking, recommend using the CRAN version
library(devtools)# functions for interacting with packages (if needed)
library(tidyverse) # these functions are used in the template to work with data frames
# Install packages from GitHub if not done or not updated in a while - else comment out
# Note that 'install_local' can also work, as long as repo is synced should be same outcome
# install_github('NEONScience/neonOSqc')
# install_github("NEONScience/restR2")
# Load internal NEON packages
library(neonOSqc) # OS QC functions
library(restR2)
dtOptions = list(
paging = FALSE,
scrollX = TRUE,
scrollY = "42vh",
scrollCollapse = TRUE,
buttons = 'csv',
dom='B<"top"i>t',
columnDefs = list(
list(className = "dt-left", targets = "_all")
)
)
# Set script type from render file
scriptType <- params$monthlyAnnual
annual = ifelse(scriptType == "annual", T, F) # optional, if the 'annual' parameter is used to set chunks to run or not based on one month vs annual data pull
reportTimestamp <- params$reportTimestamp
reportName <- params$reportName
spectra <- try(neonUtilities::loadByProduct(
dpID='DP1.30012.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
package = "expanded",  # Important for getting downloadFileUrl
#release = "LATEST",
token = Sys.getenv('NEON_PAT'), # remove this line if you don't have a token, though everyone is encouraged to get one
silent = T))
spectra <- try(neonUtilities::loadByProduct(
dpID='DP1.30012.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
package = "expanded",  # Important for getting downloadFileUrl
#release = "LATEST",
token = Sys.getenv('NEON_PAT')), # remove this line if you don't have a token, though everyone is encouraged to get one
silent = T)
canopyFoliage <- try(neonUtilities::loadByProduct(
dpID='DP1.10026.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
#release = "LATEST",
token = Sys.getenv('NEON_PAT')),
silent = T)
if(identical(names(spectra), "NONE")){
print("There are no FSP data in this date range to check, no script outputs generated.")
knitr::knit_exit()
}else{
# Turn all tables in the list to dataframe (DF) in the global environment, where name of table = name of DF.
invisible(list2env(spectra, envir=.GlobalEnv))
}
# Set date variables for FSP QC report
startDate_checked <- "2022-01"  # Start date for data download
endDate_checked <- "2022-12"    # End date for data download
print(paste0('First year-month of input data = ', startDate_checked, '. Last year-month of input data = ', endDate_checked, "."))
# Set script type
scriptType <- "annual"
annual = TRUE # Set to TRUE for annual data pull
# What is the name and timestamp for the report? Need when outputs go to GCS
reportTimestamp <- format(Sys.time(), "%Y%m%d%H%M%S")
reportName <- paste0("fsp_annual_", format(Sys.Date(), "%Y"), "_", reportTimestamp)
# Load portal data - CFC (for cross-reference completeness checks)
canopyFoliage <- try(neonUtilities::loadByProduct(
dpID='DP1.10026.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
#release = "LATEST",
token = Sys.getenv('NEON_PAT')), # Using NEON_PAT token
silent = T)
# Load portal data - FSP (expanded package to include dataQF field)
spectra <- try(neonUtilities::loadByProduct(
dpID='DP1.30012.001',
check.size=F,
startdate = startDate_checked,
enddate = endDate_checked,
site = "all",
include.provisional = T,
package = "expanded",  # Use expanded package to include dataQF field
#release = "LATEST",
token = Sys.getenv('NEON_PAT')), # Using NEON_PAT token
silent = T)
install.packages(c("arrow", "cli", "commonmark", "curl", "data.table", "diffobj", "fs", "haven", "httpuv", "later", "openssl", "promises", "ps", "purrr", "ragg", "Rcpp", "rlang", "s2", "sass", "sf", "systemfonts", "terra", "textshaping", "tibble", "utf8", "writexl", "zip"))
install.packages(c("arrow", "cli", "commonmark", "curl", "data.table", "diffobj", "fs", "haven", "httpuv", "later", "openssl", "promises", "ps", "purrr", "ragg", "Rcpp", "rlang", "s2", "sass", "sf", "systemfonts", "terra", "textshaping", "tibble", "utf8", "writexl", "zip"))
install.packages(c("arrow", "commonmark", "curl", "diffobj", "fs", "haven", "httpuv", "later", "openssl", "promises", "ps", "purrr", "ragg", "Rcpp", "rlang", "s2", "sass", "sf", "systemfonts", "terra", "textshaping", "tibble", "utf8", "writexl", "zip"))
